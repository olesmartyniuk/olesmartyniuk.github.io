<!DOCTYPE html><html lang="uk" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><title> Обмеження одночасних потоків в C# | Мартинюк Онлайн</title><link rel="shortcut icon" href="/uk/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/uk/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/uk/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/uk/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/uk/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/uk/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/uk/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/uk/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/uk/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/uk/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/uk/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/uk/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/uk/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/uk/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/uk/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/uk/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/uk/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/uk/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/uk/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/uk/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="/assets/js/dist/lang-detector.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-166067964-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-166067964-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Мартинюк Онлайн</a></div><div class="site-subtitle font-italic">Блог про бекенд розробку на .NET</div><div class="site-title mt-0"> <a href="/posts/%D0%BE%D0%B1%D0%BC%D0%B5%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F-%D0%BE%D0%B4%D0%BD%D0%BE%D1%87%D0%B0%D1%81%D0%BD%D0%B8%D1%85-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D1%96%D0%B2-csharp/" title="In English"> <img src="/assets/img/sample/english.png" width="40px" height="40px"/> </a></div></div><ul class="w-100"><li class="nav-item"> <a href="/uk/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>СТАТТІ</span> </a><li class="nav-item"> <a href="/uk/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>КАТЕГОРІЇ</span> </a><li class="nav-item"> <a href="/uk/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>ТЕГИ</span> </a><li class="nav-item"> <a href="/uk/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>АРХІВ</span> </a><li class="nav-item"> <a href="/uk/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ПРО МЕНЕ</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/alexmartyniuk" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/alexmartyniuk" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['alexander.martinyuk','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span></span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Обмеження одночасних потоків в C#</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, May 28, 2020, 8:00 PM +0300" > May 28, 2020 <i class="unloaded">2020-05-28T20:00:00+03:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1319 words">7 min</span></div></div><div class="post-content"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="http://www.martyniuk.info/assets/img/posts/2020-05-28-constraining-concurrent-threads-in-csharp/cover.png" alt="" /></p><blockquote><p>Це переклад допису <a href="https://markheath.net/post/constraining-concurrent-threads-csharp">Constraining Concurrent Threads in C#</a> Марка Хіта - Microsoft MVP, Software Architect в NICE Systems і автора кількох бібліотек з відкритим кодом.</p></blockquote><p>Припустимо, в C# ми маємо виконати певну кількість задач, які наразі виконуються послідовно і які ми хочемо прискорити, запустивши їх паралельно. Для прикладу, уявіть, що ми завантажуємо купу веб сторінок:</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">urls</span> <span class="p">=</span> <span class="k">new</span> <span class="p">[]</span> <span class="p">{</span> 
        <span class="s">"https://github.com/naudio/NAudio"</span><span class="p">,</span> 
        <span class="s">"https://twitter.com/mark_heath"</span><span class="p">,</span> 
        <span class="s">"https://github.com/markheath/azure-functions-links"</span><span class="p">,</span>
        <span class="s">"https://pluralsight.com/authors/mark-heath"</span><span class="p">,</span>
        <span class="s">"https://github.com/markheath/advent-of-code-js"</span><span class="p">,</span>
        <span class="s">"http://stackoverflow.com/users/7532/mark-heath"</span><span class="p">,</span>
        <span class="s">"https://mvp.microsoft.com/en-us/mvp/Mark%20%20Heath-5002551"</span><span class="p">,</span>
        <span class="s">"https://github.com/markheath/func-todo-backend"</span><span class="p">,</span>
        <span class="s">"https://github.com/markheath/typescript-tetris"</span><span class="p">,</span>
<span class="p">};</span>
<span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>
<span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">url</span> <span class="k">in</span> <span class="n">urls</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">html</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"retrieved </span><span class="p">{</span><span class="n">html</span><span class="p">.</span><span class="n">Length</span><span class="p">}</span><span class="s"> characters from </span><span class="p">{</span><span class="n">url</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Щоб запустити їх паралельно, ми могли б запустити для кожного завантаження <code class="language-plaintext highlighter-rouge">Task</code> через <code class="language-plaintext highlighter-rouge">Task.Run</code> і очікувати, поки вони всі завершаться. Але як бути, якщо ми хочемо <strong>обмежити кількість одночасних завантажень</strong>? Припустимо, ми хочемо обмежити їх чотирма.</p><p>В цьому спрощеному прикладі точна кількість задач не має принципового значення, але неважко уявити ситуацію, в якій ви захочете обмежити кількість одночасних запитів до певного сервісу.</p><p>В цьому дописі я хочу розглянути чотири різні способи вирішення цієї проблеми.</p><h2 id="спосіб-1---concurrentqueue">Спосіб 1 - ConcurrentQueue</h2><p>Перший спосіб був для мене звичним підходом протягом багатьох років. Основна ідея - поставити всі завдання в чергу і обробляти їх декількома потоками, які читають з черги послідовно. Це непоганий і доволі простий підхід, який, проте, вимагає блокування черги, так як вона буде використовуватись декількома потоками одночасно. В цьому прикладі я використовую <code class="language-plaintext highlighter-rouge">ConcurrentQueue</code>, щоб зробити це потокобезпечно.</p><p>Ми заповнюємо чергу адресами сторінок для завантаження і запускаємо одну задачу для кожного потоку, які в циклі намагаються читати з черги. Потоки закінчуються, коли не лишається елементів в черзі. Ми створюємо список таких задач і потім використовуємо <code class="language-plaintext highlighter-rouge">Task.WhenAll</code>, щоб дочекатись їх завершення. Вони всі завершаться, коли завершиться останнє завантаження.</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">maxThreads</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">q</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConcurrentQueue</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="n">urls</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;();</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">n</span> <span class="p">&lt;</span> <span class="n">maxThreads</span><span class="p">;</span> <span class="n">n</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">tasks</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="nf">TryDequeue</span><span class="p">(</span><span class="k">out</span> <span class="kt">string</span> <span class="n">url</span><span class="p">))</span> 
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">html</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"retrieved </span><span class="p">{</span><span class="n">html</span><span class="p">.</span><span class="n">Length</span><span class="p">}</span><span class="s"> characters from </span><span class="p">{</span><span class="n">url</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}));</span>
<span class="p">}</span>
<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
</pre></table></code></div></div><p>Мені досі подобається цей підхід, адже він концептуально простий. Проте, можуть бути певні незручності, якщо продовжувати додавати нові завдання після того, як ми почали їх обробку. Причина в тому, що потоки, що читають з черги, можуть завершитись зарано.</p><h2 id="спосіб-2---semaphoreslim">Спосіб 2 - SemaphoreSlim</h2><p>Інший підхід (на який мене надихнула ця <a href="https://stackoverflow.com/questions/10806951/how-to-limit-the-amount-of-concurrent-async-i-o-operations/10810730#10810730">відповідь зі StackOverflow</a>) - це скористатись <code class="language-plaintext highlighter-rouge">SemaphoreSlim</code> з <code class="language-plaintext highlighter-rouge">initialCount</code> рівним максимальному числу потоків. Потім ми використовуємо <code class="language-plaintext highlighter-rouge">WaitAsync</code> для очікування моменту, коли можна буде запустити наступну задачу. Таким чином, ми відразу стартуємо чотири задачі, але далі повинні дочекатись, поки якась з них завершиться перед тим, як виконається <code class="language-plaintext highlighter-rouge">WaitAsync</code> і з’явиться можливість додати наступну.</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">allTasks</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">throttler</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SemaphoreSlim</span><span class="p">(</span><span class="n">initialCount</span><span class="p">:</span> <span class="n">maxThreads</span><span class="p">);</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">url</span> <span class="k">in</span> <span class="n">urls</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">throttler</span><span class="p">.</span><span class="nf">WaitAsync</span><span class="p">();</span>
    <span class="n">allTasks</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span>
        <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">try</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">html</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"retrieved </span><span class="p">{</span><span class="n">html</span><span class="p">.</span><span class="n">Length</span><span class="p">}</span><span class="s"> characters from </span><span class="p">{</span><span class="n">url</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">finally</span>
            <span class="p">{</span>
                <span class="n">throttler</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}));</span>
<span class="p">}</span>
<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">allTasks</span><span class="p">);</span>
</pre></table></code></div></div><p>Цей код трішки наочніший, ніж підхід з <code class="language-plaintext highlighter-rouge">ConcurrentQueue</code>. Також він призводить до ситуації, коли ми отримаємо список з потенційно великою кількістю вже завершених задач. Але цей підхід має перевагу, якщо під час виконання задач ви генеруєте нові.</p><p>Для прикладу, для передачі великого файлу до Azure Blob Storage ви можете послідовно читати порціями в 1MB, але бажаєте завантажувати їх по чотири одночасно. Ви не хочете читати всі порції файлу до моменту поки їх не потрібно буде відправити, оскільки це потребує багато часу і пам’яті. З даним підходом ми можемо створювати задачу саме в той момент, коли потік звільнився і готовий завантажувати наступну порцію. Це набагато ефективніше.</p><h2 id="спосіб-3---parallelforeach">Спосіб 3 - Parallel.ForEach</h2><p>Метод <a href="https://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.foreach(v=vs.110).aspx"><code class="language-plaintext highlighter-rouge">Parallel.ForEach</code></a>, на перший погляд, ідеальне вирішення цієї проблеми. Ви можете просто вказати <code class="language-plaintext highlighter-rouge">MaxDegreeOfParallelism</code> і визначити <code class="language-plaintext highlighter-rouge">Action</code>, що буде виконуватись для кожного елементу у вашому <code class="language-plaintext highlighter-rouge">IEnumerable</code>:</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">options</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ParallelOptions</span><span class="p">()</span> <span class="p">{</span> <span class="n">MaxDegreeOfParallelism</span> <span class="p">=</span> <span class="n">maxThreads</span> <span class="p">};</span>
<span class="n">Parallel</span><span class="p">.</span><span class="nf">ForEach</span><span class="p">(</span><span class="n">urls</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">url</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">html</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"retrieved </span><span class="p">{</span><span class="n">html</span><span class="p">.</span><span class="n">Length</span><span class="p">}</span><span class="s"> characters from </span><span class="p">{</span><span class="n">url</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">});</span>
</pre></table></code></div></div><p>Виглядає гарно і просто, чи не так? Проте, тут є приховані граблі. Так як <code class="language-plaintext highlighter-rouge">Parallel.ForEach</code> приймає <code class="language-plaintext highlighter-rouge">Action</code>, а не <code class="language-plaintext highlighter-rouge">Func&lt;T&gt;</code>, його можна використовувати лише зі синхронними функціями. Ви могли помітити, що ми викрутились, додавши <code class="language-plaintext highlighter-rouge">.Result</code> після <code class="language-plaintext highlighter-rouge">GetStringAsync</code>, але це небезпечний прийом, який використовувати не рекомендується.</p><p>Тож, на жаль, цей підхід можна задіяти, якщо у вас є синхронні методи, які необхідно виконати паралельно. Існує Nuget пакет, що реалізує <a href="https://www.nuget.org/packages/AsyncEnumerator/1.1.0">асинхронну версію Parallel.ForEach</a>, тож ви можете спробувати його, якщо бажаєте отримати щось на кшталт:</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">await</span> <span class="n">uris</span><span class="p">.</span><span class="nf">ParallelForEachAsync</span><span class="p">(</span>
    <span class="k">async</span> <span class="n">url</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">html</span> <span class="p">=</span> <span class="k">await</span> <span class="n">httpClient</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"retrieved </span><span class="p">{</span><span class="n">html</span><span class="p">.</span><span class="n">Length</span><span class="p">}</span><span class="s"> characters from </span><span class="p">{</span><span class="n">url</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="n">maxDegreeOfParalellism</span><span class="p">:</span> <span class="n">maxThreads</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="спосіб-4---політика-перемичка-бібліотеки-polly">Спосіб 4 - політика “Перемичка” бібліотеки Polly</h2><p>Останій варіант - скористатись <a href="https://github.com/App-vNext/Polly/wiki/Bulkhead">політикою ізоляції Перемичка (Bulkhead)</a> бібліотеки <a href="https://github.com/App-vNext/Polly">Polly</a>. Ця політика обмежує кількість одночасних викликів і, <em>за бажанням</em>, дозволяє ставити в чергу виклики, що потрапили під обмеження.</p><p>Нижче ми налаштовуємо політику перемички з обмеженням на число одночасних викликів та без обмеження на кількість задач, що очікують свого запуску в черзі. Далі ми просто викликаємо метод <code class="language-plaintext highlighter-rouge">ExecuteAsync</code> в циклі, дозволяючи або негайно стартувати задачу, або поставити її в чергу, якщо задач забагато.</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">bulkhead</span> <span class="p">=</span> <span class="n">Policy</span><span class="p">.</span><span class="nf">BulkheadAsync</span><span class="p">(</span><span class="n">maxThreads</span><span class="p">,</span> <span class="n">Int32</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;();</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">url</span> <span class="k">in</span> <span class="n">urls</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">t</span> <span class="p">=</span> <span class="n">bulkhead</span><span class="p">.</span><span class="nf">ExecuteAsync</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">html</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"retrieved </span><span class="p">{</span><span class="n">html</span><span class="p">.</span><span class="n">Length</span><span class="p">}</span><span class="s"> characters from </span><span class="p">{</span><span class="n">url</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="n">tasks</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
</pre></table></code></div></div><p>Аналогічно до інших згаданих способів ми зберігаємо задачі до списку і використовуємо <code class="language-plaintext highlighter-rouge">Task.WhenAll</code> для очікування їх завершення. Варто зазначити, що даний шаблон насправді створений для ситуацій, в яких одночасні завдання генеруються декількома потоками (для прикладу, з контролерів ASP.NET). Вони можуть просто використовувати спільну політику перемички і ви лише запускаєте задачу з <code class="language-plaintext highlighter-rouge">await bulkhead.ExecuteAsync(...)</code>. Тож цей підхід дуже простий і добре підходить для тих ситуацій, для яких він був спроєктований.</p><h2 id="висновок">Висновок</h2><p>Паралелізація може значно прискорити виконання вашої програми. Але, якщо вона використовується неправильно, то може сама створити більше проблем, аніж розв’язує. Ці шаблони дозволяють вам використовувати обмежену кількість потоків для обробки групи задач. Єдине, з чим необхідно визначитись, - це спосіб, у який завдання створюються. Вони наявні з самого початку, чи створюються в процесі, в момент, коли вже відбувається обробка попередніх завдань? Також питання: ви генеруєте ці задачі послідовно з одного потоку чи декілька потоків мають можливість додавати задачі?</p><p>Звичайно, я впевнений, що існують інші красиві способи розв’язання цієї проблеми, тож дайте знати в коментарях, який ваш улюблений.</p><h2 id="коментар-стівена-клірі">Коментар Стівена Клірі</h2><blockquote><p>Від перекладача:</p><p>В обговорення цього допису завітав <a href="https://blog.stephencleary.com/">Стівен Клірі</a> - автор відомої книги <a href="http://shop.oreilly.com/product/0636920266624.do?cmp=af-code-books-video-product_cj_0636920266624_7489747">Concurrency in C# Cookbook</a>. Я думаю, його коментар варто перекласти також.</p></blockquote><p>Я думаю, важливо розрізняти синхронну та асинхронну конкурентність. Синхронна конкурентність (паралелізм) це використання декількох потоків, і це правильний вибір, якщо ви маєте код, що інтенсивно використовує центральний процесор (CPU-bound). Асинхронна конкурентність - це форма виконання, що не вимагає додаткових потоків, і це правильний вибір, коли ви маєте код, що працює з введенням-виведенням (I/O-bound).</p><p>Наведений приклад (завантаження веб сторінок) - це введення-виведення, а отже, тут краще підходить асинхронна конкурентність. Ось чому способи з <code class="language-plaintext highlighter-rouge">Parallel</code> / <code class="language-plaintext highlighter-rouge">ConcurrentQueue</code> / <code class="language-plaintext highlighter-rouge">BlockingCollection</code> врешті виглядають незграбно: блокування потоків і т.ін. Вони справді незамінні у світі синхронної конкуренції і з ними, звісно, можна ров’язати дану проблему, але цей розв’язок буде менш ефективним.</p><p>Для завантаження більше підходять методи асинхронної конкурентності. Вони включають використання <code class="language-plaintext highlighter-rouge">SemaphoreSlim</code> з <code class="language-plaintext highlighter-rouge">Task.WhenAll</code> (але без необов’язкового <code class="language-plaintext highlighter-rouge">Task.Run</code>), і <code class="language-plaintext highlighter-rouge">TPL ActionBlock / BufferBlock</code> (працюють як асинхронна <code class="language-plaintext highlighter-rouge">ConcurrentQueue</code>).</p><p>Наприклад, підхід з <code class="language-plaintext highlighter-rouge">SempahoreSlim</code> може бути спрощений до такого:</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">throttler</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SemaphoreSlim</span><span class="p">(</span><span class="n">initialCount</span><span class="p">:</span> <span class="n">maxThreads</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">urls</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="k">async</span> <span class="n">url</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">throttler</span><span class="p">.</span><span class="nf">WaitAsync</span><span class="p">();</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">html</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"retrieved </span><span class="p">{</span><span class="n">html</span><span class="p">.</span><span class="n">Length</span><span class="p">}</span><span class="s"> characters from </span><span class="p">{</span><span class="n">url</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">finally</span>
    <span class="p">{</span>
        <span class="n">throttler</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
</pre></table></code></div></div><p>І його навіть можна спростити ще більше, якщо визначити метод розширення <code class="language-plaintext highlighter-rouge">LockAsync</code> для <code class="language-plaintext highlighter-rouge">SemaphoreSlim</code>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/uk/categories/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F/'>Програмування</a>, <a href='/uk/categories/net/'>.NET</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Популярні Теги</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/uk/tags/net/">.NET</a> <a class="post-tag" href="/uk/tags/asp-net-core/">ASP.NET Core</a> <a class="post-tag" href="/uk/tags/c/">C#</a> <a class="post-tag" href="/uk/tags/heroku/">Heroku</a> <a class="post-tag" href="/uk/tags/%D0%BF%D0%B5%D1%80%D0%B5%D0%BA%D0%BB%D0%B0%D0%B4/">переклад</a> <a class="post-tag" href="/uk/tags/codility-com/">codility.com</a> <a class="post-tag" href="/uk/tags/entity-framework/">Entity Framework</a> <a class="post-tag" href="/uk/tags/identity/">identity</a> <a class="post-tag" href="/uk/tags/linq/">LINQ</a> <a class="post-tag" href="/uk/tags/postgresql/">PostgreSQL</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Loading comments from <a href="https://disqus.com/">Disqus</a> ...</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//martyniuk.disqus.com/embed.js', disqusConfig: function() { this.page.title = ''; this.page.url = 'http://www.martyniuk.info/uk/posts/%D0%BE%D0%B1%D0%BC%D0%B5%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F-%D0%BE%D0%B4%D0%BD%D0%BE%D1%87%D0%B0%D1%81%D0%BD%D0%B8%D1%85-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D1%96%D0%B2-csharp/'; this.page.identifier = '/posts/%D0%BE%D0%B1%D0%BC%D0%B5%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F-%D0%BE%D0%B4%D0%BD%D0%BE%D1%87%D0%B0%D1%81%D0%BD%D0%B8%D1%85-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D1%96%D0%B2-csharp/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/uk/tags/net/">.NET</a> <a class="post-tag" href="/uk/tags/asp-net-core/">ASP.NET Core</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/uk/tags/heroku/">Heroku</a> <a class="post-tag" href="/uk/tags/%D0%BF%D0%B5%D1%80%D0%B5%D0%BA%D0%BB%D0%B0%D0%B4/">переклад</a> <a class="post-tag" href="/uk/tags/codility-com/">codility.com</a> <a class="post-tag" href="/uk/tags/entity-framework/">Entity Framework</a> <a class="post-tag" href="/uk/tags/identity/">identity</a> <a class="post-tag" href="/tags/linq/">LINQ</a> <a class="post-tag" href="/uk/tags/postgresql/">PostgreSQL</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="http://www.martyniuk.info{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
